<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640">

    <link rel="stylesheet" href="stylesheets/core.css" media="screen">
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)">
    <link rel="stylesheet" href="stylesheets/github-light.css">

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>王峥</title>
  </head>

  <body>
 <canvas id="myfrist" width="1024" height="768">
        当前浏览器不支持Canvas,请更换浏览器，如果支持canvas则这句话不显示
        canvas与SVG
        canvas对图像处理较强，适合图片很多的情况，比如游戏，绘制后不能控制
        SVG绘制的是图形对象，可控制，然而图片较多的话性能就不行了，做地图用SVG
                <!-- (function () {
            var lastTime = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                window.cancelAnimationFrame =
          window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
            }

            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function (callback, element) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function () { callback(currTime + timeToCall); },
              timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };

            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function (id) {
                    clearTimeout(id);
                };
        } ()); -->
    </canvas>
    <script type="text/javascript">
        window.onload = function(){
            var canvas = document.getElementById("myfrist");
            canvas.width = 1024;
            canvas.height = 768;
            if(canvas.getContext("2d")){//判断是否支持
                var context = canvas.getContext("2d");
            }
            else{
                alert("h弱鸡");
            }
            //context.moveTo(100,100);//起点状态坐标
            //context.lineTo(700,700);//终点状态坐标
            context.lineWidth = 2;//粗细
            context.strokeStyle = "#058"//颜色
            //context.stroke();//绘制
            // $("#myfrist").click(function(event){
            //     $("#myfrist").off();
            //     var X = event.pageX;
            //     var Y = event.pageY;
            //     context.moveTo(X,Y);
            //     $("#myfrist").mousemove(function(event){
            //         X = event.pageX;
            //         Y = event.pageY;
            //         context.lineTo(X,Y);
            //         context.stroke();
            //     });
            // })
            //鼠标跟随绘画效果
            
            context.fillRect(10,10,10,20);
            context.strokeRect(20,20,30,40);
            context.clearRect(15,15,15,15);
            //context.beginPath();//beginPath()的意义是区分路径而不是字面的开始，stroke和fill方法会将从其开始只到他上一个beginPath中的路径信息绘制出来，当绘制多个不同属性的路径时，用begin.Path()分开,理解成开始则是重新开始的意思
            context.moveTo(110,75);
            context.arc(75,75,50,0,Math.PI*2,true);
            context.moveTo(110,75);
            context.arc(75,75,35,0,Math.PI,false);
            context.moveTo(200,300);
            context.arc(200,200,50,0,Math.PI*2,true);
            context.stroke();//stroke()和fill()才能实现绘制，arc只是先告诉浏览器需要如何绘制
            context.beginPath();
            var a = 0.01;
            //context.arc(400,400,100,0,Math.PI*a,false)//false决定绘制方向，0是角度起点，Math.PI是终点，起点位置是右，中，角度的计算是从右中这一点算的，正角度往上，负角度往下，角度和绘制方向是互相不关联的，这就是我一开始动画没实现的原因
            // var r = 0,g = 0,b = 0;
            var numr = 0;numg = 255;
            var draw_circle = setInterval(function(){
                context.arc(400,400,100,Math.PI*(a-0.01),Math.PI*a,false);//这句话也要每次都重新定义，否则无法实现动画，起点和终点必须都是变量，否则会变成扇子

                //动画结束代码
                 if(a<=2){a+=0.01}
                 else{
                     clearInterval(draw_circle);
                     context.beginPath();//beginPath（）妙用，同一路径内，点都是连着的，如果此处没有初始化一下，两个圆会有条线连起来，需要moveTo一下，但坐标计算麻烦，直接初始化可以不用计算，不知道closePath有没有效果//closePath()闭合路径，绘制一条从当前点到起始点的线
                     context.fileStyle="#f00";//fileStyle只在context是通过file（）方法绘制的时候才有效，stroke（）绘制的只是轮廓，没有填充
                     context.arc(400,400,20,0,Math.PI*2,false);
                     context.fill();
                     return;//break只能跳出循环，无法跳出函数，return可以跳出函数，后面的不管是什么都不执行
                 };
                
                //动画结束代码
                
                // (function (r,g,b){
                //     if(r<255){
                //         ++r;
                //         console.log(r)
                //         return r;
                //     }
                //     if(g<255){
                //         ++g;
                //         return;
                //     }
                //     if(b<255){
                //         ++b;
                //         return;
                //     }
                //     if(r==255&&g==255&&b==255){
                //         r = 0,g = 0, b = 0;
                //     }                    
                // })(r,g,b);//此处匿名函数虽然能够执行，但是值传不出去
                //context.strokeStyle = obj.dynamicColor16bin(); 
                //context.strokeStyle = obj.dynamicColor255(); //还是没有平滑的改变颜色
                //
                //
                //
                //
                //a+=0.01;
                if(numr<=255){
                    numr+=2; 
                }else if(numr>=255){
                    numr = 0;
                    numg-=4;
                }//颜色判断好麻烦，营改另写一个计时器
                context.strokeStyle = "rgb("+numr+","+numg+",255)";              
                context.stroke();
            },10);
            //动态画圆
            var obj = {
                dynamicColor16bin:function(){
                    var color_array = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","a","b","c","d","e","f"]
                    var random = '';
                    for(i=0;i<6;i++){
                        random+=color_array[parseInt(22*Math.random())]
                    }
                    return color = "#"+random;
                },
                dynamicColor255:function(){
                    var r=255,g=255,b=255;
                    return color = "rgb("+parseInt(r*Math.random())+","+parseInt(g*Math.random())+","+parseInt(r*Math.random())+")" ;
                }
            }
            var img = new Image();
            img.src = "images/banner_1.jpg"
            img.onload = function(){
                context.drawImage(img,400,400);
                context.stroke;
            }
            var p = new Path2D("M10 10 h 90 v 80 h -80 Z");
            context.fill(p);
            //context.beginPath();
            function draw(){
                for(var i=0;i<6;i++){
                    for(var j=0;j<6;j++){
                        context.fillStyle = 'rgb('+Math.floor(255-42.5*i)+','+Math.floor(255-42.5*j)+',0';
                        context.fillRect(j*50,i*50,50,50);
                    }
                }
            }
            draw();
            console.log(draw.toString());
            console.log(Boolean('1'));
            function C(){
                this.a = 1;
                return false;
            }
            console.log(typeof new C());
        }
    </script> 
  </body>
</html>
